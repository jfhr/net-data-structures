<#@ template language="C#" #>
<#@ output extension=".cs" #>


using System;


/**
This code was auto-generated by a T4 text template. Changes made to this code will be overwritten when the text
template is executed. Please change the template directly instead.
*/

namespace NetDataStructures.LinearAlgebra
{

<#
    var types = new (string Name, bool IsInt, bool IsSigned)[]
    {
        ("Single", false, true),
        ("Double", false, true),
        ("Byte", true, false),
        ("SByte", true, true),
        ("Int16", true, true),
        ("UInt16", true, false),
        ("Int32", true, true),
        ("UInt32", true, false),
        ("Int64", true, true),
        ("UInt64", true, false),
    };

    foreach ((string name, bool isInt, bool isSigned) in types)
    {
#>
    /// <summary>
    /// Vector of <see cref="<#=name #>"/> values.
    /// </summary>
    public readonly struct <#=name #>Vector
    {
        private static Double Tolerance => LinearAlgebraOptions.Tolerance;

        /// <summary>
        /// The dimension (length) of this vector.
        /// </summary>
        public int Dimension => _vector.Length;

        /// <summary>
        /// Gets the element of this vector at the 0-based index <paramref name="i"/>.
        /// </summary>
        public <#=name #> this[int i] => _vector[i];

        private readonly <#=name #>[] _vector;

        /// <summary>
        /// Creates the zero-vector for the given dimension.
        /// </summary>
        public <#=name #>Vector(int dimension)
        {
            _vector = new <#=name #>[dimension];
        }

        /// <summary>
        /// Creates a vector based on the given array of numbers.
        /// </summary>
        public <#=name #>Vector(<#=name #>[] numbers)
        {
            _vector = numbers.Clone() as <#=name #>[];
        }

        /// <summary>
        /// Runs an action on each element of the vector in order.
        /// </summary>
        /// <param name="action">
        /// Action that takes two arguments: (index, value).
        /// </param>
        private void ForEachElement(Action<int, <#=name #>> action)
        {
            for (int i = 0; i < Dimension; i++)
            {
                action(i, _vector[i]);
            }
        }

        /// <summary>
        /// Applies a transformation function on each element of the vector
        /// and returns a new vector with the same size, consisting of the
        /// results of the transformation function.
        /// </summary>
        /// <param name="transformation">
        /// Function that takes two arguments: (index, value)
        /// and returns a new value.
        /// </param>
        private <#=name #>Vector CopyTransformEachElement(Func<int, <#=name #>, <#=name #>> transformation)
        {
            var result = new <#=name #>[Dimension];

            for (int i = 0; i < Dimension; i++)
            {
                result[i] = transformation(i, _vector[i]);
            }

            return new <#=name #>Vector(result);
        }

        private static void ValidateSameDimension(<#=name #>Vector a, <#=name #>Vector b, string operation)
        {
            if (a.Dimension != b.Dimension)
            {
                throw new ArgumentException(
                    $"Cannot {operation} two vectors with different dimensions, got: " +
                    $"{a.Dimension} and {b.Dimension}");
            }
        }

        /// <summary>
        /// Returns the sum of a and b as a new vector.
        /// </summary>
        public static <#=name #>Vector operator +(<#=name #>Vector a, <#=name #>Vector b)
        {
            ValidateSameDimension(a, b, "add");
            return a.CopyTransformEachElement((index, value) => (<#=name#>) (value + b[index]));
        }

        /// <summary>
        /// Returns a - b as a new vector.
        /// </summary>
        public static <#=name #>Vector operator -(<#=name #>Vector a, <#=name #>Vector b)
        {
            ValidateSameDimension(a, b, "subtract");
            return a.CopyTransformEachElement((index, value) => (<#=name#>) (value - b[index]));
        }

        /// <summary>
        /// Returns v * s as a new vector.
        /// </summary>
        public static <#=name #>Vector operator *(<#=name #>Vector v, <#=name #> s)
        {
            return v.CopyTransformEachElement((index, value) => (<#=name#>) (value * s));
        }

        /// <summary>
        /// Returns s * v as a new vector.
        /// </summary>
        public static <#=name #>Vector operator *(<#=name #> s, <#=name #>Vector v)
        {
            return v * s;
        }

<# if (isSigned) { #>
        /// <summary>
        /// Returns the negation of a vector as a new vector.
        /// </summary>
        public static <#=name #>Vector operator -(<#=name #>Vector v)
        {
            return (<#=name#>) (-1) * v;
        }
<# } #>

        /// <summary>
        /// Returns the scalar product of two vectors.
        /// </summary>
        public static <#=name #> operator *(<#=name #>Vector a, <#=name #>Vector b)
        {
            ValidateSameDimension(a, b, "compute the dot product of");
            <#=name #> result = 0;
            a.ForEachElement((index, value) => result += (<#=name#>) (value * b[index]));
            return result;
        }


    <# foreach ((string targetName, _, _) in types) if (targetName != name) { #>
        /// <summary>
        /// Converts this vector into a vector of a different underlying type, 
        /// using the default numeric conversions.
        /// </summary>
        public static explicit operator <#=targetName #>Vector (<#=name #>Vector v) 
        {
            var result = new <#=targetName #>[v.Dimension];
            for (int i = 0; i < v.Dimension; i++) 
            {
                result[i] = (<#=targetName #>) v[i];
            }
            return new <#=targetName #>Vector(result);
        } 
    <# } #>

        /// <summary>
        /// Returns the angle between two vectors of the same dimension.
        /// </summary>
        public static double AngleBetween(<#=name #>Vector a, <#=name #>Vector b)
        {
            ValidateSameDimension(a, b, "compute the angle between");
            if (Math.Abs(a.Magnitude()) < Tolerance || Math.Abs(b.Magnitude()) < Tolerance)
            {
                throw new ArgumentException("Cannot get the angle between the zero vector and another vector.");
            }

            return Math.Acos(a * b / (a.Magnitude() * b.Magnitude()));
        }

        /// <summary>
        /// Indicates if two vectors are perpendicular within the <see cref="Tolerance"/>.
        /// </summary>
        public static bool ArePerpendicular(<#=name #>Vector a, <#=name #>Vector b)
        {
<# if (isInt && isSigned) { #>
            return Math.Abs(a * b) == 0;
<# } else if (isInt) { #>
            return a * b == 0;
<# } else { #>
            return Math.Abs(a * b) < Tolerance;
<# } #>
        }

        /// <summary>
        /// Indicates if two vectors are parallel within the <see cref="Tolerance"/>.
        /// </summary>
        public static bool AreParallel(<#=name #>Vector a, <#=name #>Vector b)
        {
            var angle = AngleBetween(a, b);
            return Math.Abs(angle % Math.PI) < Tolerance;
        }

        /// <summary>
        /// Returns the orthogonal projection of <paramref name="x"/>
        /// onto <paramref name="v"/>, as a new vector.
        /// </summary>
        public static <#=name #>Vector OrthogonalProjection(<#=name #>Vector x, <#=name #>Vector v)
        {
            return (<#=name #>) (x * v / (v * v)) * v;
        }

        /// <summary>
        /// Returns the cross product between two 3d-vectors as a new 3d-vector.
        /// </summary>
        public static <#=name #>Vector CrossProduct(<#=name #>Vector a, <#=name #>Vector b)
        {
            if (a.Dimension != 3 || b.Dimension == 3)
            {
                throw new ArgumentException(
                    $"Cross product expects two 3d-Vectors, got dimensions: {a.Dimension}, {b.Dimension}");
            }

            return new <#=name #>Vector(new[]
            {
                (<#=name #>) (a[2] * b[3] - a[3] * b[2]),
                (<#=name #>) (a[3] * b[1] - a[1] * b[3]),
                (<#=name #>) (a[1] * b[2] - a[2] * b[1]),
            });
        }

        /// <summary>
        /// Returns the magnitude of this vector.
        /// </summary>
        public double Magnitude()
        {
            return Math.Sqrt(this * this);
        }

        /// <summary>
        /// Creates a <see cref="string"/>-representation of this matrix.
        /// </summary>
        public override string ToString()
        {
            return "Vector {" + string.Join(", ", _vector) + "}";
        }
    }
<# } #>

}