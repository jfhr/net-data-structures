<#@ template language="C#" #>
<#@ output extension=".cs" #>


using System;
using System.Text;


/**
This code was auto-generated by a T4 text template. Changes made to this code will be overwritten when the text
template is executed. Please change the template directly instead.
*/

namespace NetDataStructures.LinearAlgebra
{

<#
    var types = new (string Name, bool IsInt, bool IsSigned)[]
    {
        ("Single", false, true),
        ("Double", false, true),
        ("Byte", true, false),
        ("SByte", true, true),
        ("Int16", true, true),
        ("UInt16", true, false),
        ("Int32", true, true),
        ("UInt32", true, false),
        ("Int64", true, true),
        ("UInt64", true, false),
        ("nint", true, true),
        ("nuint", true, false),
    };

    foreach ((string name, bool isInt, bool isSigned) in types)
    {
#>

    /// <summary>
    /// Matrix of <see cref="<#=name #>"/> values.
    /// </summary>
    public readonly struct <#=name #>Matrix : IEquatable<<#=name #>Matrix>
    {
        /// <summary>
        /// Gets the number of rows of the matrix.
        /// </summary>
        public int RowCount => _matrix.GetLength(0);

        /// <summary>
        /// Gets the number of columns of the matrix.
        /// </summary>
        public int ColumnCount => _matrix.GetLength(1);

        /// <summary>
        /// Gets the element of this matrix at index the zero-based indices
        /// <paramref name="x"/> and <paramref name="y"/>.
        /// </summary>
        public <#=name #> this[int x, int y] => _matrix[x, y];

        private double Tolerance => LinearAlgebraOptions.Tolerance;

        private readonly <#=name #>[,] _matrix;

        /// <summary>
        /// Creates a new matrix based on a 2d-array of numbers.
        /// </summary>
        public <#=name #>Matrix(<#=name #>[,] numbers)
        {
            _matrix = numbers.Clone() as <#=name #>[,];
        }

        /// <summary>
        /// Creates a new matrix based on the given matrix with the given dimensions.
        /// </summary>
        /// <remarks>
        /// The dimensions can be larger, but not smaller, than those of the base matrix.
        /// If they are larger, the surplus fields will be initialized to zero.
        /// </remarks>
        public <#=name #>Matrix(<#=name #>Matrix baseMatrix, int sizeX, int sizeY)
        {
            if (sizeX < baseMatrix.RowCount)
            {
                throw new ArgumentException("The new size can't be less than the base size.", nameof(sizeX));
            }

            if (sizeY < baseMatrix.ColumnCount)
            {
                throw new ArgumentException("The new size can't be less than the base size.", nameof(sizeY));
            }

            var newMatrix = new <#=name #>[sizeX, sizeY];
            baseMatrix.ForEachElement((x, y, value) => newMatrix[x, y] = value);
            _matrix = newMatrix;
        }

        /// <summary>
        /// Runs an action on each element of the matrix in order.
        /// </summary>
        /// <param name="action">
        /// Action that takes three arguments: (rowIndex, columnIndex, value).
        /// </param>
        private void ForEachElement(Action<int, int, <#=name #>> action)
        {
            for (int x = 0; x < RowCount; x++)
            {
                for (int y = 0; y < ColumnCount; y++)
                {
                    action(x, y, _matrix[x, y]);
                }
            }
        }

        /// <summary>
        /// Applies a transformation function on each element of the matrix
        /// and returns a new matrix with the same size, consisting of the
        /// results of the transformation function.
        /// </summary>
        /// <param name="transformation">
        /// Function that takes three arguments: (rowIndex, columnIndex, value)
        /// and returns a new value.
        /// </param>
        private <#=name #>Matrix CopyTransformEachElement(Func<int, int, <#=name #>, <#=name #>> transformation)
        {
            var target = new <#=name #>[RowCount, ColumnCount];

            for (int x = 0; x < RowCount; x++)
            {
                for (int y = 0; y < ColumnCount; y++)
                {
                    target[x, y] = transformation(x, y, _matrix[x, y]);
                }
            }

            return new <#=name #>Matrix(target);
        }

        /// <summary>
        /// Returns the transpose of this matrix as a new matrix.
        /// </summary>
        public <#=name #>Matrix Transpose()
        {
            var target = new <#=name #>[ColumnCount, RowCount];
            ForEachElement((x, y, value) => { target[y, x] = value; });
            return new <#=name #>Matrix(target);
        }

        /// <summary>
        /// Indicates if this matrix is symmetric (ie equal to its transpose).
        /// </summary>
        public bool IsSymmetric() => this == this.Transpose();

        /// <summary>
        /// Adds two matrices of the same dimensions and returns the result as a new matrix.
        /// </summary>
        /// <exception cref="MatrixMathException">
        /// The two matrices are not of the same dimension.
        /// </exception>
        public static <#=name #>Matrix operator +(<#=name #>Matrix m1, <#=name #>Matrix m2)
        {
            if (m1.RowCount != m2.RowCount)
            {
                throw new MatrixMathException($"Attempt to add two matrices with different numbers of rows: " +
                                              $"{m1.RowCount} and {m2.RowCount}.");
            }

            if (m1.ColumnCount != m2.ColumnCount)
            {
                throw new MatrixMathException($"Attempt to add two matrices with different numbers of columns: " +
                                              $"{m1.ColumnCount}, {m2.ColumnCount}.");
            }

            return m1.CopyTransformEachElement((x, y, value) => (<#=name #>) (value + m2._matrix[x, y]));
        }

        /// <summary>
        /// Calculates the product of a matrix and a scalar and returns the result as a new matrix.
        /// </summary>
        public static <#=name #>Matrix operator *(<#=name #>Matrix m, <#=name #> scalar)
        {
            return m.CopyTransformEachElement((x, y, value) => (<#=name #>) (value * scalar));
        }

        /// <summary>
        /// Calculates the product of a matrix and a scalar and returns the result as a new matrix.
        /// </summary>
        public static <#=name #>Matrix operator *(<#=name #> scalar, <#=name #>Matrix m)
        {
            return m * scalar;
        }

        /// <summary>
        /// Calculates the matrix product of two matrices of compatible sizes.
        /// This operation is not commutative.
        /// </summary>
        /// <exception cref="MatrixMathException">
        /// The number of rows of <paramref name="m1"/> is not equal to the number of columns of <paramref name="m2"/>.
        /// </exception>
        public static <#=name #>Matrix operator *(<#=name #>Matrix m1, <#=name #>Matrix m2)
        {
            if (m1.RowCount != m2.ColumnCount)
            {
                throw new MatrixMathException($"Attempt to multiply a matrix with {m1.ColumnCount} columns with " +
                                              $"another matrix with {m1.RowCount} rows.");
            }

            <#=name #>[,] result = new <#=name #>[m1.RowCount, m2.ColumnCount];

            for (int x = 0; x < m1.RowCount; x++)
            {
                for (int y = 0; y < m2.ColumnCount; y++)
                {
                    for (int n = 0; n < m1.ColumnCount; n++)
                    {
                        result[x, y] += (<#=name #>) (m1[x, n] * m2[n, y]);
                    }
                }
            }

            return new <#=name #>Matrix(result);
        }

        /// <summary>
        /// Calculates the product of a matrix and a vector.
        /// </summary>
        /// <exception cref="MatrixMathException">
        /// The number of columns of <paramref name="a"/> is not equal to the length of <paramref name="v"/>.
        /// </exception>
        public static <#=name #>Vector operator *(<#=name #>Matrix a, <#=name #>Vector v)
        {
            if (a.ColumnCount != v.Dimension)
            {
                throw new MatrixMathException($"Attempt to multiply a matrix with {a.ColumnCount} columns with a " +
                                              $"vector of length {v.Dimension}.");
            }

            <#=name #>[] result = new <#=name #>[a.RowCount];

            for (int x = 0; x < a.RowCount; x++)
            {
                for (int y = 0; y < v.Dimension; y++)
                {
                    result[x] += (<#=name #>) (a[x, y] * v[y]);
                }
            }

            return new <#=name #>Vector(result);
        }

        public static bool operator ==(<#=name #>Matrix m1, <#=name #>Matrix m2) => m1.Equals(m2);
        public static bool operator !=(<#=name #>Matrix m1, <#=name #>Matrix m2) => !m1.Equals(m2);

        public override bool Equals(object obj)
        {
            return obj is <#=name #>Matrix other && Equals(other);
        }

        public bool Equals(<#=name #>Matrix other)
        {
            if (RowCount != other.RowCount || ColumnCount != other.ColumnCount)
            {
                return false;
            }

            for (int x = 0; x < RowCount; x++)
            {
                for (int y = 0; y < ColumnCount; y++)
                {

<# if (isInt) { #>
                    if (this[x, y] != other[x, y])
<# } else { #>
                    if (Math.Abs(this[x, y] - other[x, y]) > Tolerance)
<# } #>
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        public override int GetHashCode()
        {
            return (_matrix != null ? _matrix.GetHashCode() : 0);
        }

        /// <summary>
        /// Creates a <see cref="string"/>-representation of this matrix.
        /// </summary>
        public override string ToString()
        {
            var s = new StringBuilder(9 + RowCount * ColumnCount * 3);
            s.Append("Matrix {");
            for (int i = 0; i < RowCount; i++) {
                if (i > 0) s.Append(", ");
                s.Append("{");
                for (int j = 0; j < ColumnCount; j++) {
                    if (j > 0) s.Append(", ");
                    s.Append(this[i, j]);
                }
                s.Append("}");
            }
            return s.ToString();
        }
    }

<# } #>




    [Serializable]
    public class MatrixMathException : Exception
    {
        public MatrixMathException()
        {
        }

        public MatrixMathException(string message) : base(message)
        {
        }

        public MatrixMathException(string message, Exception inner) : base(message, inner)
        {
        }

        protected MatrixMathException(
            System.Runtime.Serialization.SerializationInfo info,
            System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }
    }

}